import random
import math
from collections import deque

def calculer_distance_totale(solution, matrice_distances):
    """Calcule la distance totale d'une solution (route complète)"""
    distance_totale = 0
    for i in range(len(solution) - 1):
        distance_totale += matrice_distances[solution[i]][solution[i + 1]]

    distance_totale += matrice_distances[solution[-1]][solution[0]]
    return distance_totale


def generer_voisin(solution):
    """Génère un voisin aléatoire en échangeant deux villes"""
    voisin = solution[:]
    i, j = random.sample(range(len(solution)), 2)
    voisin[i], voisin[j] = voisin[j], voisin[i]
    return voisin


def recuit_simule(matrice_distances, temperature_initiale, temperature_finale, 
                  taux_refroidissement, iterations_par_temperature):
    """
    Algorithme de Recuit Simulé pour le problème du voyageur de commerce
    
    Paramètres:
    - matrice_distances: matrice des distances entre villes
    - temperature_initiale: température de départ (élevée)
    - temperature_finale: température d'arrêt (proche de 0)
    - taux_refroidissement: facteur de refroidissement (0 < alpha < 1)
    - iterations_par_temperature: nombre d'itérations à chaque palier de température
    """
    

    nombre_villes = len(matrice_distances)
    solution_actuelle = list(range(nombre_villes))
    random.shuffle(solution_actuelle)
    

    meilleure_solution = solution_actuelle[:]
    meilleure_distance = calculer_distance_totale(solution_actuelle, matrice_distances)
    
    distance_actuelle = meilleure_distance
    
    temperature = temperature_initiale
    
    iteration_globale = 0
    
    historique_distances = []
    historique_temperatures = []
    
    print(f"{'='*60}")
    print(f"Démarrage du Recuit Simulé")
    print(f"{'='*60}")
    print(f"Solution initiale: {solution_actuelle}")
    print(f"Distance initiale: {distance_actuelle}")
    print(f"Température initiale: {temperature_initiale}")
    print(f"{'='*60}\n")
    
    while temperature > temperature_finale:
        
        for _ in range(iterations_par_temperature):
            iteration_globale += 1
            
            solution_voisine = generer_voisin(solution_actuelle)
            distance_voisine = calculer_distance_totale(solution_voisine, matrice_distances)
            
            delta = distance_voisine - distance_actuelle
            
            if delta < 0:
                solution_actuelle = solution_voisine
                distance_actuelle = distance_voisine
                
                if distance_actuelle < meilleure_distance:
                    meilleure_solution = solution_actuelle[:]
                    meilleure_distance = distance_actuelle
                    print(f"Itération {iteration_globale}: Nouvelle meilleure solution trouvée!")
                    print(f"  Distance: {meilleure_distance}, Température: {temperature:.4f}")
                    
            else:
                probabilite_acceptation = math.exp(-delta / temperature)
                
                if random.random() < probabilite_acceptation:
                    solution_actuelle = solution_voisine
                    distance_actuelle = distance_voisine
            
            historique_distances.append(distance_actuelle)
            historique_temperatures.append(temperature)
        
        temperature *= taux_refroidissement
        
        if iteration_globale % 1000 == 0:
            print(f"Itération {iteration_globale}: T={temperature:.4f}, "
                  f"Distance actuelle={distance_actuelle}, "
                  f"Meilleure={meilleure_distance}")
    
    print(f"\n{'='*60}")
    print(f"Fin du Recuit Simulé")
    print(f"{'='*60}")
    print(f"Nombre total d'itérations: {iteration_globale}")
    print(f"Température finale: {temperature:.6f}")
    
    return meilleure_solution, meilleure_distance, historique_distances, historique_temperatures


matrice_distances = [
    [0, 2, 2, 7, 15, 2, 5, 7, 6, 5],
    [2, 0, 10, 4, 7, 3, 7, 15, 8, 2],
    [2, 10, 0, 1, 4, 3, 3, 4, 2, 3],
    [7, 4, 1, 0, 2, 15, 7, 7, 5, 4],
    [7, 10, 4, 2, 0, 7, 3, 2, 2, 7],
    [2, 3, 3, 7, 7, 0, 1, 7, 2, 10],
    [5, 7, 3, 7, 3, 1, 0, 2, 1, 3],
    [7, 7, 4, 7, 2, 7, 2, 0, 1, 10],
    [6, 8, 2, 5, 2, 2, 1, 1, 0, 15],
    [5, 2, 3, 4, 7, 10, 3, 10, 15, 0]
]

temperature_initiale = 1000
temperature_finale = 0.01
taux_refroidissement = 0.95  
iterations_par_temperature = 100

meilleure_solution, meilleure_distance, historique_distances, historique_temperatures = \
    recuit_simule(matrice_distances, 
                  temperature_initiale, 
                  temperature_finale, 
                  taux_refroidissement, 
                  iterations_par_temperature)

print(f"\n{'='*60}")
print(f"RÉSULTAT FINAL")
print(f"{'='*60}")
print(f"Meilleure solution trouvée (Recuit Simulé): {meilleure_solution}")
print(f"Distance minimale: {meilleure_distance}")
print(f"{'='*60}")
